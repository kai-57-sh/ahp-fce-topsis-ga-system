# 遗传算法(GA)方案优化详细说明

## 概述

遗传算法(Genetic Algorithm, GA)是AHP-FCE-TOPSIS-GA系统中的优化模块，用于自动搜索最优的无人作战体系配置方案。GA通过模拟生物进化过程，在大型解空间中高效地寻找接近最优的配置组合。

## 核心工作原理

### 1. 染色体编码方案

#### 1.1 基因结构设计
```python
gene_config = {
    'platform_types': ['USV_Unmanned_Surface_Vessel', 'UUV_Unmanned_Underwater_Vessel'],
    'num_deployment_zones': 1,
    'deployment_radius': 50,
    'task_types': ['surveillance', 'anti_submarine', 'mine_countermeasures']
}
```

#### 1.2 染色体组成
每个染色体(个体)代表一个完整的配置方案，包含以下基因段：

**基因段1：平台数量配置**
```
基因[0]: USV数量 (范围: 2-12)
基因[1]: UUV数量 (范围: 2-12)
```

**基因段2：部署坐标配置**
```
基因[2]: 部署区域X坐标 (范围: 20-80)
基因[3]: 部署区域Y坐标 (范围: 20-80)
```

**基因段3：任务分配配置**
```
基因[4]: 监视任务分配平台数 (范围: 1-20)
基因[5]: 反潜任务分配平台数 (范围: 1-20)
基因[6]: 反水雷任务分配平台数 (范围: 1-20)
```

**示例染色体：** `[8, 6, 45, 55, 7, 4, 3]`
- 8个USV，6个UUV
- 部署在坐标(45, 55)
- 监视任务7个平台，反潜任务4个平台，反水雷任务3个平台

### 2. 染色体解码机制

#### 2.1 解码流程
```python
def decode_chromosome(chromosome, gene_config):
    configuration = {
        'scheme_id': 'ga_generated',
        'scheme_name': 'GA Optimized Configuration',
        'platform_inventory': {},
        'deployment_plan': {},
        'task_assignments': {},
        'operational_constraints': {},
        'simulation_parameters': {}
    }

    # 1. 解码平台配置
    for i, platform_type in enumerate(platform_types):
        count = int(chromosome[i])
        configuration['platform_inventory'][platform_type] = {
            'count': count,
            'types': {}
        }

    # 2. 解码部署计划
    configuration['deployment_plan']['primary_sector'] = {
        'coordinates': [chromosome[2], chromosome[3]],
        'radius_km': 50
    }

    # 3. 解码任务分配
    task_types = ['surveillance', 'anti_submarine', 'mine_countermeasures']
    for i, task_type in enumerate(task_types):
        assigned_platforms = int(chromosome[4 + i])
        configuration['task_assignments'][f'{task_type}_mission'] = {
            'assigned_platforms': assigned_platforms,
            'priority': 'high' if i == 0 else 'medium'
        }

    return configuration
```

#### 2.2 自动约束计算
```python
# 计算运行约束
total_platforms = sum(config['count'] for config in configuration['platform_inventory'].values())
base_budget = 2.5 * total_platforms  # 简化成本计算

configuration['operational_constraints'] = {
    'total_platforms': total_platforms,
    'max_budget_million_usd': base_budget * 1.2,  # 20%缓冲
    'deployment_area_km2': 5000 * (total_platforms / 10.0),
    'endurance_hours': 72,
    'communication_range_km': 100
}

# 生成仿真参数
configuration['simulation_parameters'] = {
    'detection_range_factor': 1.0 + (total_platforms - 10) * 0.05,
    'coordination_efficiency': 0.8 - (total_platforms - 10) * 0.01,
    'weapon_effectiveness': 0.85,
    'network_bandwidth_mbps': 100 + (total_platforms - 10) * 10,
    'stealth_factor': 0.7
}
```

### 3. 约束验证机制

#### 3.1 硬约束检验
```python
def validate_constraints(configuration, constraints):
    validation_result = {'valid': True, 'violations': [], 'warnings': []}

    # 1. 平台数量约束
    total_platforms = sum(data.get('count', 0)
                         for data in configuration['platform_inventory'].values())

    if total_platforms < constraints.get('min_platforms', 1):
        validation_result['valid'] = False
        validation_result['violations'].append(f"平台数量不足: {total_platforms}")

    if total_platforms > constraints.get('max_platforms', 20):
        validation_result['valid'] = False
        validation_result['violations'].append(f"平台数量超限: {total_platforms}")

    # 2. 预算约束
    estimated_cost = total_platforms * 2.5  # 每平台250万美元
    max_budget = constraints.get('max_budget_million_usd', 100.0)

    if estimated_cost > max_budget:
        validation_result['valid'] = False
        validation_result['violations'].append(f"预算超支: ${estimated_cost:.1f}M > ${max_budget:.1f}M")

    # 3. 部署边界约束
    coords = configuration['deployment_plan']['primary_sector']['coordinates']
    deployment_bounds = constraints.get('deployment_bounds',
                                      {'min_x': 0, 'max_x': 100, 'min_y': 0, 'max_y': 100})

    x, y = coords[0], coords[1]
    if not (deployment_bounds['min_x'] <= x <= deployment_bounds['max_x']):
        validation_result['valid'] = False
        validation_result['violations'].append(f"X坐标越界: {x}")

    # 4. 任务覆盖约束
    task_assignments = configuration.get('task_assignments', {})
    total_assigned = sum(assignment.get('assigned_platforms', 0)
                        for assignment in task_assignments.values())

    if total_assigned > total_platforms:
        validation_result['warnings'].append(f"分配平台超出现有数量: {total_assigned} > {total_platforms}")

    return validation_result
```

#### 3.2 约束类型说明
- **硬约束(Hard Constraints)**：违反则方案无效，适应度设为极低值(0.001)
- **软约束(Soft Constraints)**：违反给予小惩罚，但方案仍可参与进化

## 适应度函数设计

### 1. 适应度函数核心逻辑

```python
def fitness_function(ga_instance, solution, solution_idx,
                     indicator_config, fuzzy_config, expert_judgments,
                     constraints, gene_config):
    try:
        # 步骤1: 染色体解码
        configuration = decode_chromosome(solution, gene_config)

        # 步骤2: 约束验证
        constraint_result = validate_constraints(configuration, constraints)
        if not constraint_result['valid']:
            return 0.001  # 无效方案给予极低适应度

        # 步骤3: AHP-FCE-TOPSIS评估
        evaluation_result = evaluate_single_scheme(
            configuration, indicator_config, fuzzy_config, expert_judgments
        )

        # 步骤4: 提取Ci得分作为基础适应度
        fitness = evaluation_result.get('ci_score', 0.0)

        # 步骤5: 应用软约束惩罚
        penalty = 0.0
        for warning in constraint_result.get('warnings', []):
            penalty += 0.1  # 每个警告扣减0.1

        fitness = max(0.001, fitness - penalty)  # 确保最小适应度

        return fitness

    except Exception as e:
        print(f"适应度函数计算失败: {e}")
        return 0.001  # 异常情况给予极低适应度
```

### 2. 适应度函数的来源和设计原理

#### 2.1 Ci Score作为适应度的理论基础

**为什么选择Ci Score？**

1. **综合性评估**：Ci Score是AHP-FCE-TOPSIS算法的最终输出，综合了：
   - AHP权重分析的专家经验
   - FCE模糊评价的定性处理
   - TOPSIS排序的多目标优化

2. **标准化范围**：Ci Score范围固定在[0, 1]，便于作为适应度值：
   - Ci = 1.0：完全贴近正理想解，最优方案
   - Ci = 0.0：完全贴近负理想解，最差方案
   - 中间值：表示方案在理想解之间的相对位置

3. **数学意义明确**：
   ```
   Ci = D- / (D+ + D-)
   ```
   其中：
   - D+：方案到正理想解的距离
   - D-：方案到负理想解的距离
   - Ci值越大，方案越贴近正理想解

#### 2.2 适应度函数的数学模型

**基础适应度模型：**
```
fitness_base = Ci_Score
```

**惩罚模型：**
```
fitness_penalty = Σ(warning_i × 0.1)
```

**最终适应度：**
```
fitness_final = max(0.001, fitness_base - fitness_penalty)
```

**约束处理模型：**
```
if (hard_constraints_violated):
    fitness = 0.001
else:
    fitness = fitness_final
```

#### 2.3 适应度函数的优势

1. **多目标整合**：将复杂的多指标评估简化为单一数值
2. **约束处理**：硬约束排除无效解，软约束引导搜索方向
3. **数值稳定性**：确保适应度值在合理范围内，避免算法数值问题
4. **物理意义明确**：每个适应度值都有明确的军事效能含义

### 3. 遗传算法参数配置

#### 3.1 标准参数设置
```python
ga_params = {
    'population_size': 20,        # 种群大小
    'num_generations': 50,        # 进化代数
    'num_parents_mating': 4,      # 父代数量
    'crossover_rate': 0.8,        # 交叉概率
    'mutation_rate': 0.2,         # 变异概率
    'parent_selection_type': 'tournament',  # 父代选择方式
    'crossover_type': 'single_point',       # 交叉方式
    'mutation_type': 'random',              # 变异方式
    'keep_parents': 1,                       # 保留精英个体
    'mutation_percent_genes': 20             # 变异基因百分比
}
```

#### 3.2 基因空间定义
```python
gene_space = [
    {'low': 2, 'high': 12},   # USV数量
    {'low': 2, 'high': 12},   # UUV数量
    {'low': 20, 'high': 80},  # X坐标
    {'low': 20, 'high': 80},  # Y坐标
    {'low': 1, 'high': 20},   # 监视任务平台
    {'low': 1, 'high': 20},   # 反潜任务平台
    {'low': 1, 'high': 20}    # 反水雷任务平台
]
```

## 遗传操作机制

### 1. 选择操作(Selection)

#### 1.1 锦标赛选择(Tournament Selection)
```python
# 锦标赛选择机制
def tournament_selection(population, fitness_scores, tournament_size=3):
    selected_parents = []

    for _ range(num_parents):
        # 随机选择tournament_size个个体
        tournament_indices = np.random.choice(len(population), tournament_size, replace=False)
        tournament_fitness = [fitness_scores[i] for i in tournament_indices]

        # 选择适应度最高的个体
        winner_idx = tournament_indices[np.argmax(tournament_fitness)]
        selected_parents.append(population[winner_idx])

    return selected_parents
```

**优势：**
- 选择压力可控，通过调整锦标赛大小
- 保持种群多样性，避免过早收敛
- 计算效率高，适合大规模种群

### 2. 交叉操作(Crossover)

#### 2.1 单点交叉(Single Point Crossover)
```python
def single_point_crossover(parent1, parent2, crossover_rate=0.8):
    if np.random.random() > crossover_rate:
        return parent1.copy(), parent2.copy()  # 不交叉，直接复制

    # 随机选择交叉点
    crossover_point = np.random.randint(1, len(parent1) - 1)

    # 创建子代
    child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])
    child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])

    return child1, child2
```

**示例：**
```
父代1: [8, 6, 45, 55, 7, 4, 3]
父代2: [10, 4, 30, 70, 5, 6, 2]
交叉点: 3

子代1: [8, 6, 45, 70, 5, 6, 2]  # 继承父代1前3个基因，父代2后4个基因
子代2: [10, 4, 30, 55, 7, 4, 3]  # 继承父代2前3个基因，父代1后4个基因
```

### 3. 变异操作(Mutation)

#### 3.1 随机变异(Random Mutation)
```python
def random_mutation(chromosome, mutation_rate=0.2, gene_space=None):
    mutated_chromosome = chromosome.copy()

    for i in range(len(mutated_chromosome)):
        if np.random.random() < mutation_rate:
            # 在基因范围内随机变异
            low = gene_space[i]['low']
            high = gene_space[i]['high']
            mutated_chromosome[i] = np.random.randint(low, high + 1)

    return mutated_chromosome
```

**变异类型：**
- **小幅变异**：在当前值附近小范围调整
- **大幅变异**：在整个基因空间内随机选择新值
- **自适应变异**：根据种群多样性动态调整变异率

### 4. 种群多样性管理

#### 4.1 多样性计算
```python
def calculate_population_diversity(population):
    if len(population) < 2:
        return 1.0

    # 计算汉明距离
    total_distance = 0.0
    pair_count = 0

    for i in range(len(population)):
        for j in range(i + 1, len(population)):
            # 汉明距离 = 不同基因的数量
            distance = np.sum(population[i] != population[j])
            total_distance += distance
            pair_count += 1

    # 标准化多样性指标
    max_distance = population.shape[1]  # 最大可能汉明距离
    avg_distance = total_distance / pair_count
    diversity = avg_distance / max_distance

    return min(1.0, max(0.0, diversity))
```

#### 4.2 多样性监控策略
- **实时监控**：每代计算种群多样性
- **早停机制**：多样性过低时增加变异率
- **重启策略**：种群完全收敛时重新初始化部分个体

## 进化过程监控

### 1. 代际追踪机制

```python
def on_generation(ga_instance):
    generation = ga_instance.generations_completed

    # 计算适应度统计
    fitness_scores = ga_instance.last_generation_fitness
    best_fitness = np.max(fitness_scores)
    avg_fitness = np.mean(fitness_scores)

    # 计算种群多样性
    diversity = calculate_population_diversity(ga_instance.population)

    # 存储历史数据
    generation_history['best_fitness'].append(best_fitness)
    generation_history['avg_fitness'].append(avg_fitness)
    generation_history['diversity'].append(diversity)

    # 显示进度
    if generation % 5 == 0:
        print(f"Generation {generation:3d} | "
              f"Best Fitness: {best_fitness:.4f} | "
              f"Avg Fitness: {avg_fitness:.4f} | "
              f"Diversity: {diversity:.3f}")
```

### 2. 收敛判断标准

#### 2.1 收敛条件
```python
convergence_criteria = {
    'target_fitness': 0.85,        # 目标适应度
    'max_generations': 50,          # 最大代数
    'convergence_generations': 10,  # 连续改进代数
    'min_diversity': 0.1            # 最小多样性
}
```

#### 2.2 收敛状态判断
```python
def check_convergence(generation_history, criteria):
    best_fitness = generation_history['best_fitness']

    # 1. 达到目标适应度
    if best_fitness[-1] >= criteria['target_fitness']:
        return {'converged': True, 'reason': 'target_fitness_reached'}

    # 2. 连续多代无显著改进
    if len(best_fitness) >= criteria['convergence_generations']:
        recent_fitness = best_fitness[-criteria['convergence_generations']:]
        if max(recent_fitness) - min(recent_fitness) < 0.01:
            return {'converged': True, 'reason': 'no_improvement'}

    # 3. 种群多样性过低
    diversity = generation_history['diversity']
    if diversity[-1] < criteria['min_diversity']:
        return {'converged': True, 'reason': 'low_diversity'}

    return {'converged': False, 'reason': 'still_improving'}
```

## 实际应用效果

### 1. 优化结果示例

```
优化完成！
最优适应度: 0.8547
总代数: 50
最终多样性: 0.342

最优配置方案:
- USV数量: 9
- UUV数量: 7
- 部署坐标: [42, 58]
- 监视任务: 8个平台
- 反潜任务: 5个平台
- 反水雷任务: 3个平台

最终评估结果:
- Ci Score: 0.8547
- 排名: 1/8
- 验证状态: PASSED
```

### 2. 收敛曲线分析

典型的GA优化收敛过程包含以下阶段：

1. **初期阶段(1-10代)**：快速适应度提升，高多样性
2. **中期阶段(11-30代)**：适应度稳步提升，多样性逐渐降低
3. **后期阶段(31-50代)**：适应度趋于稳定，可能收敛到局部最优

### 3. 参数调优建议

#### 3.1 种群大小
- **小种群(10-20)**：收敛快但易陷入局部最优
- **中等种群(20-50)**：平衡探索和利用，推荐使用
- **大种群(50-100)**：全局搜索能力强但计算成本高

#### 3.2 交叉和变异率
- **高交叉率(0.7-0.9)**：促进优良基因组合
- **中等变异率(0.1-0.3)**：保持种群多样性
- **自适应策略**：根据收敛进度动态调整

## 总结

遗传算法在AHP-FCE-TOPSIS-GA系统中扮演着关键的优化角色：

1. **搜索效率**：在大规模配置空间中高效搜索
2. **多目标优化**：通过Ci Score适应度函数整合复杂评估指标
3. **约束处理**：确保生成可行且合理的配置方案
4. **自动化程度**：减少人工试错，提高方案设计效率

适应度函数以Ci Score为核心，充分利用了AHP-FCE-TOPSIS算法的评估结果，确保遗传算法的优化方向与军事效能评估标准完全一致，实现了从"评估"到"优化"的无缝衔接。